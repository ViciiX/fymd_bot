import random, os, datetime

from nonebot.adapters.onebot.v11 import Bot, Event
from nonebot.adapters.onebot.v11.message import Message, MessageSegment
from nonebot.adapters.onebot.v11.event import GroupMessageEvent
from nonebot import on_fullmatch, on_message, on_regex
from nonebot.params import RegexGroup

from ..utils.file import DataFile, Item
from ..utils import util as Util
from ..utils import plugin_util as Putil

detect_pool_avaliable = on_message(block = False)
forhelp = on_regex("^å¡ç‰Œå¸®åŠ© (\\d+)$|^å¡ç‰Œå¸®åŠ©$")
my_card = on_fullmatch("æˆ‘çš„å¡ç‰Œ")
my_level_card = on_regex("^æˆ‘çš„å¡ç‰Œ (C|B|A|S|SSS|SSR)$")
card_pools = on_regex("^å¡æ±  (\\d+)$|^å¡æ± $")
get_cards = on_regex("^æŠ½å¡ (\\d+) (\\d+)$")
check = on_regex("^æŸ¥çœ‹å¡ç‰Œ (\\d+)$")

LINE = "â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”"
LEVELS = ['SSR', 'SSS', 'S', 'A', 'B', 'C']

@detect_pool_avaliable.handle()
async def _():
	data = DataFile("[data]/DATA/card")
	all_card = data.get_raw("cards.json")
	for pool_name, values in all_card.items():
		dtime = datetime.datetime.now()
		deadline = values.get("deadline", None)
		if (deadline != None):
			deadline = datetime.datetime.strptime(deadline, "%Y-%m-%d %H:%M:%S")
			if (dtime >= deadline):
				pool_data = data.get("cards.json", pool_name, {})
				pool_data["avaliable"] = False
				data.set("cards.json", pool_name, pool_data)
				print(f"å¡æ± {pool_name}è¶…æ—¶ï¼Œå·²ç¦ç”¨")

@forhelp.handle()
async def _(event: Event, args = RegexGroup()):
	if (args[0] == None):
		data = DataFile("[data]/DATA")
		help_dict = data.get("help.json", "card", {})
		mes = f"""ã€å¡ç‰Œã€‘åŠŸèƒ½åˆ—è¡¨
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
{"\n".join([f"{i}.{list(help_dict.keys())[i]}" for i in range(len(help_dict.keys()))])}
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
å‘é€â€œå¡ç‰Œå¸®åŠ© [åºå·]â€è·å–è¯¦ç»†å¸®åŠ©
å¦‚ï¼šå¡ç‰Œå¸®åŠ© 1
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”"""
		await forhelp.finish(mes)
	else:
		data = DataFile("[data]/DATA")
		help_dict = data.get("help.json", "card", {})
		help_list = list(help_dict.keys())
		index = int(args[0])
		if (0 <= index and index <= len(help_list)-1):
			await Putil.reply(forhelp, event, f"""{help_list[index]}
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
{"\n".join(help_dict[help_list[index]])}""")
		else:
			await Putil.reply(forhelp, event, "404 Not Fucked")

@card_pools.handle()
async def _(bot: Bot, event: Event, args = RegexGroup()):
	all_card = DataFile("[data]/DATA/card").get_raw("cards.json")
	if (args[0] == None):
		mes = ["ğŸ“å½“å‰å¯ç”¨çš„æ‰€æœ‰å¡æ± ", LINE]
		all_card = get_avaliable_pools()
		for i in range(len(all_card)):
			mes.append(f"{i}.{list(all_card)[i]}")
		mes.extend([LINE, "å¡æ± å‰æ•°å­—ä¸ºå¡æ± id", "å‘é€â€œå¡æ±  [id]â€æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯"])
		await card_pools.finish("\n".join(mes))
	else:
		index = int(args[0])
		if (0 <= index and index < len(get_avaliable_pools())):
			await Putil.processing(bot, event)
			pool_name = list(get_avaliable_pools())[index]
			pool = all_card.get(pool_name)
			deadline = pool.get("deadline", None)
			mes = ["âœ¨å¡æ± ä¿¡æ¯âœ¨", LINE, f"å¡æ± åï¼š{pool_name}", f"å¡æ± idï¼š{index}"]
			amounts = [len(pool.get(level, [])) for level in LEVELS]
			mes.extend([f"å¡ç‰Œæ•°ï¼š{sum(amounts)}å¼ ", f"ä»·æ ¼ï¼š{pool.get("cost", "???")}ğŸ¦Œå¸/æŠ½"])
			if (deadline != None):
				dtime = datetime.datetime.now()
				deadline = datetime.datetime.strptime(deadline, "%Y-%m-%d %H:%M:%S")
				mes.append(f"ğŸ’¥é™æ—¶æ—¶é—´ï¼š {Util.format_delta_time(deadline - dtime)}")
			else:
				mes.append(f"âœ…æ—¶é—´ä¸é™")
			mes.append(LINE)
			weight = pool.get("weight", {})
			weight_total = sum([weight.get(level) for level in LEVELS if (weight.get(level, None) != None)])
			msg = []
			for level in LEVELS:
				if (level in pool):
					mes.append(f"ã€{level}ã€{amounts[LEVELS.index(level)]}å¼  ({weight.get(level, 0)/weight_total*100}%)")
					msg.append(f"ã€{level}ã€çº§å¡ç‰Œï¼š\n" + "\n".join(pool.get(level)))
			mes.extend([LINE, "å¡æ± ä»‹ç»ï¼š", pool.get("text", "æ— ")])
			msg.insert(0, "\n".join(mes))
			await Putil.sending(bot, event)
			await Putil.send_forward_msg(bot, event, {"bot": (Putil.bot_id, "FyMdå¡æ± ")}, [("bot", msg)])

		else:
			await card_pools.finish("å¡æ± ä¸å­˜åœ¨ï¼")

@my_card.handle()
async def _(event: Event):
	item = Item(f"[data]/user/{event.user_id}/card/mycard.json")
	cards = {}
	mes = [f"{event.sender.nickname} çš„å¡ç‰Œåº“ï¼š", LINE]
	total = 0
	for card in item.items:
		card_level = card.get("data", {}).get("level", None)
		cards[card_level] = cards.get(card_level, 0) + card.get("amount", 0)
		total += card.get("amount", 0)
	mes.append(f"æ€»è®¡ï¼š{total}å¼ ")
	for level, count in cards.items():
		mes.append(f"{level}çº§å¡ç‰‡ï¼š {count}å¼ ")
	mes.append(LINE)
	mes.append("å‘é€â€œæˆ‘çš„å¡ç‰Œ ã€ç­‰çº§ã€‘â€æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯")
	await Putil.reply(my_card, event, "\n".join(mes))

@my_level_card.handle()
async def _(event: Event, args = RegexGroup()):
	item = Item(f"[data]/user/{event.user_id}/card/mycard.json")
	s = Item.format([x for x in item.items if (x.get("data", {}).get("level", None) == args[0])], "[call:get_id].ã€[data:level]ã€‘[name] * [amount]", callables = {"get_id": [get_id, {"items": item.items}]})
	mes = [f"{event.sender.nickname} çš„ã€{args[0]}ã€çº§å¡ç‰Œï¼š", LINE] + s.split("\n")
	mes.append(LINE)
	mes.append("å¡ç‰Œå‰æ•°å­—ä¸ºèƒŒåŒ…å†…å¡ç‰Œid")
	mes.append("å‘é€â€œæŸ¥çœ‹å¡ç‰Œ ã€å¡ç‰Œidã€‘â€æŸ¥çœ‹å¡ç‰Œä¿¡æ¯")
	await Putil.reply(my_level_card, event, "\n".join(mes))

@check.handle()
async def _(bot: Bot, event: Event, args = RegexGroup()):
	args = list(args)
	item = Item(f"[data]/user/{event.user_id}/card/mycard.json")
	index = int(args[0])
	if (0 <= index and index < len(item.items)):
		await Putil.processing(bot, event)
		current_item = item.items[index]
		path = os.path.join(DataFile("[data]/DATA/card/src").path, f"{current_item["name"]}.png")
		byte = None
		with open(path, "rb") as f:
			byte = Util.img_process(f.read())
		mes = [LINE] + f"""{current_item["name"]}
å¡æ± ï¼šã€{current_item.get("data", {}).get("pool", "?")}ã€
ç­‰çº§ï¼š ã€{current_item.get("data", {}).get("level", "?")}ã€
æ‹¥æœ‰è€…ï¼š{event.sender.nickname}
æ‹¥æœ‰æ•°é‡ï¼š{current_item.get("amount", "?")}""".split("\n")
		mes.append(LINE)
		text = current_item.get("data", {}).get("text", "")
		if (text != ""):
			mes.append(text)
		await Putil.sending(bot, event)
		await Putil.reply(check, event, MessageSegment.image(byte) + "\n".join(mes))
	else:
		await Putil.reply(check, event, "æœªæ‰¾åˆ°è¯¥å¡ç‰Œidï¼")

@get_cards.handle()
async def _(bot: Bot, event: Event, args = RegexGroup()):
	data = DataFile(f"[data]/user/{event.user_id}")
	pool = int(args[0])
	times = int(args[1])
	cdata = DataFile("[data]/DATA/card")
	if (0 <= pool and pool < len(get_avaliable_pools())):
		if (0 < times and times <= 20):
			pool_name = get_avaliable_pools()[pool]
			cost = int(cdata.get("cards.json", pool_name, {}).get("cost", "???"))
			if (data.remove_num("profile", "coin", times * cost)):
				await Putil.processing(bot, event)
				cards = get_card(pool_name, times)
				item = Item(f"[data]/user/{event.user_id}/card/mycard.json")
				mes = [f"{event.sender.nickname} çš„{times}è¿æŠ½å¡è®°å½•", f"å¡æ± ï¼š{pool_name}", f"å¡ç‰Œå›¾ç‰‡ä¸ºç¼©ç•¥å›¾ï¼ŒåŸå›¾è¯·åœ¨â€œæˆ‘çš„å¡ç‰Œâ€ä¸­æŸ¥çœ‹"]
				for card in cards:
					level = pick_level(pool_name, card)
					item.add(card, 1, {"level": level, "pool": pool_name, "text": cdata.get("cards.json", pool_name, {}).get("card_hint", "")})
					mes.append(MessageSegment.image(Util.thumbnail(os.path.join(cdata.path, f"src/{card}.png"), (100, 150))))
					mes.append({"S": "âœ¨Niceï¼âœ¨\n", "SSS": "ğŸ‰Ohhhhhhï¼ğŸ‰\n", "SSR": "ğŸŠğŸ‘‘è¿™ã€è¿™æ˜¯ï¼Ÿï¼ğŸ‘‘ğŸŠ\n"}.get(level, "") + f"æ­å–œä½ æŠ½åˆ°äº†ã€{level}ã€çº§å¡ç‰Œï¼š\n{card}ï¼" + {"S": "\nGood Luckï¼", "SSS": "\næ¬§çš‡ï¼", "SSR": "\nå“‡ï¼é‡‘è‰²ä¼ è¯´ï¼ï¼"}.get(level, ""))
				await Putil.sending(bot, event)
				await Putil.send_forward_msg(bot, event, {"bot": [Putil.bot_id, "FyMdæŠ½å¡"]}, [("bot", mes)])
			else:
				await Putil.reply(get_cards, event, f"éœ€è¦{times * cost}ğŸ¦Œå¸ï¼")
		else:
			await Putil.reply(get_cards, event, "æœ€å¤§åªèƒ½20è¿å“¦ï¼")
	else:
		await Putil.reply(get_cards, event, "å¡æ± ä¸å­˜åœ¨ï¼")

def get_card(pool, count):
	data = DataFile("[data]/DATA/card")
	pool =  data.get("cards.json", pool, {})
	all_card = [pool.get(x) for x in LEVELS if (pool.get(x, None) != None)]
	weight = pool.get("weight", {})
	weight = [weight.get(level) for level in LEVELS if (weight.get(level, None) != None)]
	result = []
	for i in range(count):
		choice_card = random.choices(all_card, weight)
		result.append(random.choice(choice_card[0]))
	return result

def pick_level(pool_name, name):
	all_card = DataFile("[data]/DATA/card").get("cards.json", pool_name, {})
	for level in LEVELS:
		if (name in all_card.get(level, [])):
			return level
	return None

def get_id(item, items):
	return items.index(item)

def get_by_id(_id):
	ac = get_all_card()
	try:
		return ac[_id]
	except Exception as e:
		return -1

def get_all_card():
	all_card = DataFile("[data]/DATA/card").get_raw("cards.json")
	ac = []
	for pool, value in all_card.items():
		for level in LEVELS:
			ac.extend(value.get(level, []))
	return ac

def get_avaliable_pools():
	all_card = DataFile("[data]/DATA/card").get_raw("cards.json")
	result = []
	for pool_name, values in all_card.items():
		if (values.get("avaliable", True) == True):
			result.append(pool_name)
	return result